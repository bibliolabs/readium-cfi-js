{
  "version": 3,
  "file": "readium-cfi-js.js",
  "sources": [
    "cfi_parser_gen.js",
    "cfi_parser.js",
    "cfi_runtime_errors.js",
    "cfi_instructions.js",
    "cfi_interpreter.js",
    "cfi_generator.js",
    "cfi_API.js",
    "readium-cfi-js.js",
    "epubCfi.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACx6CA,ADy6CA;ACx6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpHA,ADqHA;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtbA,ADubA;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjeA,ADkeA;ACjeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA,ADiBA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "EPUBcfiParser = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { fragment: peg$parsefragment },\n        peg$startRuleFunction  = peg$parsefragment,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = \"epubcfi(\",\n        peg$c2 = { type: \"literal\", value: \"epubcfi(\", description: \"\\\"epubcfi(\\\"\" },\n        peg$c3 = \")\",\n        peg$c4 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c5 = function(fragmentVal) { \r\n                \r\n                return { type:\"CFIAST\", cfiString:fragmentVal };\r\n            },\n        peg$c6 = \",\",\n        peg$c7 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c8 = function(stepVal, localPathVal, rangeLocalPath1Val, rangeLocalPath2Val) {\r\n\r\n                return { type:\"range\", path:stepVal, localPath:localPathVal, range1:rangeLocalPath1Val, range2:rangeLocalPath2Val };\r\n          },\n        peg$c9 = function(stepVal, localPathVal) { \r\n\r\n                return { type:\"path\", path:stepVal, localPath:localPathVal }; \r\n            },\n        peg$c10 = [],\n        peg$c11 = null,\n        peg$c12 = function(localPathStepVal, termStepVal) { \r\n\r\n                return { steps:localPathStepVal, termStep:termStepVal?termStepVal:\"\" }; \r\n            },\n        peg$c13 = \"/\",\n        peg$c14 = { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n        peg$c15 = \"[\",\n        peg$c16 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c17 = \"]\",\n        peg$c18 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c19 = function(stepLengthVal, assertVal) { \r\n\r\n                return { type:\"indexStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\r\n            },\n        peg$c20 = \"!/\",\n        peg$c21 = { type: \"literal\", value: \"!/\", description: \"\\\"!/\\\"\" },\n        peg$c22 = function(stepLengthVal, assertVal) { \r\n\r\n                return { type:\"indirectionStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\r\n            },\n        peg$c23 = \":\",\n        peg$c24 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c25 = function(textOffsetValue, textLocAssertVal) { \r\n\r\n                return { type:\"textTerminus\", offsetValue:textOffsetValue, textAssertion: textLocAssertVal?textLocAssertVal[1]:undefined };\r\n            },\n        peg$c26 = function(idVal) { \r\n\r\n                return idVal; \r\n            },\n        peg$c27 = function(csvVal, paramVal) { \r\n\r\n                return { type:\"textLocationAssertion\", csv:csvVal?csvVal:\"\", parameter:paramVal?paramVal:\"\" }; \r\n            },\n        peg$c28 = \";\",\n        peg$c29 = { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n        peg$c30 = \"=\",\n        peg$c31 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c32 = function(paramLHSVal, paramRHSVal) { \r\n\r\n                return { type:\"parameter\", LHSValue:paramLHSVal?paramLHSVal:\"\", RHSValue:paramRHSVal?paramRHSVal:\"\" }; \r\n            },\n        peg$c33 = function(preAssertionVal, postAssertionVal) { \r\n\r\n                return { type:\"csv\", preAssertion:preAssertionVal?preAssertionVal:\"\", postAssertion:postAssertionVal?postAssertionVal:\"\" }; \r\n            },\n        peg$c34 = function(stringVal) { \r\n\r\n                return stringVal.join(''); \r\n            },\n        peg$c35 = function(escSpecCharVal) { \r\n                \r\n                return escSpecCharVal[1]; \r\n            },\n        peg$c36 = /^[1-9]/,\n        peg$c37 = { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n        peg$c38 = /^[0-9]/,\n        peg$c39 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c40 = \".\",\n        peg$c41 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c42 = function(intPartVal, fracPartVal) { \r\n\r\n                return intPartVal.join('') + \".\" + fracPartVal.join(''); \r\n            },\n        peg$c43 = \"0\",\n        peg$c44 = { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n        peg$c45 = function(integerVal) { \r\n\r\n                if (integerVal === \"0\") { \r\n                  return \"0\";\r\n                } \r\n                else { \r\n                  return integerVal[0].concat(integerVal[1].join(''));\r\n                }\r\n            },\n        peg$c46 = \" \",\n        peg$c47 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n        peg$c48 = function() { return \" \"; },\n        peg$c49 = \"^\",\n        peg$c50 = { type: \"literal\", value: \"^\", description: \"\\\"^\\\"\" },\n        peg$c51 = function() { return \"^\"; },\n        peg$c52 = \"\\\"\",\n        peg$c53 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c54 = function() { return '\"'; },\n        peg$c55 = function(bracketVal) { return bracketVal; },\n        peg$c56 = \"(\",\n        peg$c57 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c58 = function(paraVal) { return paraVal; },\n        peg$c59 = function() { return \",\"; },\n        peg$c60 = function() { return \";\"; },\n        peg$c61 = function() { return \"=\"; },\n        peg$c62 = /^[a-z]/,\n        peg$c63 = { type: \"class\", value: \"[a-z]\", description: \"[a-z]\" },\n        peg$c64 = /^[A-Z]/,\n        peg$c65 = { type: \"class\", value: \"[A-Z]\", description: \"[A-Z]\" },\n        peg$c66 = \"-\",\n        peg$c67 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c68 = \"_\",\n        peg$c69 = { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n        peg$c70 = function(charVal) { return charVal; },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsefragment() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 8) === peg$c1) {\n        s1 = peg$c1;\n        peg$currPos += 8;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c2); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parserange();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsepath();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c3;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c4); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c5(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parserange() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c6;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c7); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parselocal_path();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c6;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c7); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parselocal_path();\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c8(s1, s2, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c9(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parselocal_path() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseindexStep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseindirectionStep();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseindexStep();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseindirectionStep();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseterminus();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c11;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c12(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindexStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c13;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c19(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindirectionStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c20) {\n        s1 = peg$c20;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c22(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseterminus() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c23;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetextLocationAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c25(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseidAssertion() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsetextLocationAssertion() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parsecsv();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c11;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseparameter();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c11;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c27(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseparameter() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsevalueNoSpace();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c30;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c31); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsevalueNoSpace();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c32(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsecsv() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c11;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsevalue();\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c33(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsevalueNoSpace() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsevalue() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsespace();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsespace();\n            }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseescapedSpecialChars() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecircumflex();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecircumflex();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsecircumflex();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsesquareBracket();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsecircumflex();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseparentheses();\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            s2 = peg$parsecircumflex();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecomma();\n              if (s3 !== peg$FAILED) {\n                s2 = [s2, s3];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              s2 = peg$parsecircumflex();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsesemicolon();\n                if (s3 !== peg$FAILED) {\n                  s2 = [s2, s3];\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                s2 = peg$parsecircumflex();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parseequal();\n                  if (s3 !== peg$FAILED) {\n                    s2 = [s2, s3];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c36.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c38.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c40;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            if (peg$c36.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c42(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (peg$c36.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c45(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsespace() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c46;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecircumflex() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s1 = peg$c49;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c51();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsedoubleQuote() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c52;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c54();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesquareBracket() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c15;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c16); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c18); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseparentheses() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c56;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c57); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s1 = peg$c3;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c58(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecomma() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s1 = peg$c6;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c59();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesemicolon() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c60();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseequal() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c61();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecharacter() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (peg$c62.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n      }\n      if (s1 === peg$FAILED) {\n        if (peg$c64.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        if (s1 === peg$FAILED) {\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s1 = peg$c66;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c67); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 95) {\n                s1 = peg$c68;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s1 = peg$c40;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c41); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n\ndefine(\"cfi_parser_gen\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.EPUBcfiParser;\n    };\n}(this)));\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('cfi_parser',[\"./cfi_parser_gen\"], function (cfi_parser_gen) {\r\nreturn cfi_parser_gen;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\n\r\n// Description: This is a set of runtime errors that the CFI interpreter can throw. \r\n// Rationale: These error types extend the basic javascript error object so error things like the stack trace are \r\n//   included with the runtime errors. \r\n\r\n// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, \r\n//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors\r\n//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.\r\n\r\nvar obj = {\r\n\r\nNodeTypeError: function (node, message) {\r\n\r\n    function NodeTypeError () {\r\n\r\n        this.node = node;\r\n    }\r\n\r\n    NodeTypeError.prototype = new Error(message);\r\n    NodeTypeError.constructor = NodeTypeError;\r\n\r\n    return new NodeTypeError();\r\n},\r\n\r\n// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.\r\nOutOfRangeError: function (targetIndex, maxIndex, message) {\r\n\r\n    function OutOfRangeError () {\r\n\r\n        this.targetIndex = targetIndex;\r\n        this.maxIndex = maxIndex;\r\n    }\r\n\r\n    OutOfRangeError.prototype = new Error(message);\r\n    OutOfRangeError.constructor = OutOfRangeError()\r\n\r\n    return new OutOfRangeError();\r\n},\r\n\r\n// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors\r\n//   that can occur with the various terminus conditions, it'll make more sense to revisit this. \r\nTerminusError: function (terminusType, terminusCondition, message) {\r\n\r\n    function TerminusError () {\r\n\r\n        this.terminusType = terminusType;\r\n        this.terminusCondition = terminusCondition;\r\n    }\r\n\r\n    TerminusError.prototype = new Error(message);\r\n    TerminusError.constructor = TerminusError();\r\n\r\n    return new TerminusError();\r\n},\r\n\r\nCFIAssertionError: function (expectedAssertion, targetElementAssertion, message) {\r\n\r\n    function CFIAssertionError () {\r\n\r\n        this.expectedAssertion = expectedAssertion;\r\n        this.targetElementAssertion = targetElementAssertion;\r\n    }\r\n\r\n    CFIAssertionError.prototype = new Error(message);\r\n    CFIAssertionError.constructor = CFIAssertionError();\r\n\r\n    return new CFIAssertionError();\r\n}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_errors\");\r\n    \r\n    define('cfi_runtime_errors',[],\r\n    function () {\r\n        return obj;\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_errors\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    \r\n    global.EPUBcfi.NodeTypeError = obj.NodeTypeError;\r\n    global.EPUBcfi.OutOfRangeError = obj.OutOfRangeError;\r\n    global.EPUBcfi.TerminusError = obj.TerminusError;\r\n    global.EPUBcfi.CFIAssertionError = obj.CFIAssertionError;\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiRuntimeErrors) {\r\n    \r\nvar obj = {\r\n\r\n// Description: This model contains the implementation for \"instructions\" included in the EPUB CFI domain specific language (DSL). \r\n//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). \r\n//   This object contains a set of functions that implement each of the executable instructions in the AST. \r\n\r\n\t// ------------------------------------------------------------------------------------ //\r\n\t//  \"PUBLIC\" METHODS (THE API)                                                          //\r\n\t// ------------------------------------------------------------------------------------ //\r\n\r\n\t// Description: Follows a step\r\n\t// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING\r\n\t//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been \r\n\t//   excluded.\r\n\t// REFACTORING CANDIDATE: This should be called \"followIndexStep\"\r\n\tgetNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n\t\t// Find the jquery index for the current node\r\n\t\tvar $targetNode;\r\n\t\tif (CFIStepValue % 2 == 0) {\r\n\r\n\t\t\t$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\r\n\t\t}\r\n\r\n\t\treturn $targetNode;\r\n\t},\r\n\r\n\t// Description: This instruction executes an indirection step, where a resource is retrieved using a \r\n\t//   link contained on a attribute of the target element. The attribute that contains the link differs\r\n\t//   depending on the target. \r\n\t// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to \r\n\t//   the cross origin security policy\r\n\tfollowIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n\t\tvar that = this;\r\n\t\tvar $contentDocument; \r\n\t\tvar $blacklistExcluded;\r\n\t\tvar $startElement;\r\n\t\tvar $targetNode;\r\n\r\n\t\t// TODO: This check must be expanded to all the different types of indirection step\r\n\t\t// Only expects iframes, at the moment\r\n\t\tif ($currNode === undefined || !$currNode.is(\"iframe\")) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.NodeTypeError($currNode, \"expected an iframe element\");\r\n\t\t}\r\n\r\n\t\t// Check node type; only iframe indirection is handled, at the moment\r\n\t\tif ($currNode.is(\"iframe\")) {\r\n\r\n\t\t\t// Get content\r\n\t\t\t$contentDocument = $currNode.contents();\r\n\r\n\t\t\t// Go to the first XHTML element, which will be the first child of the top-level document object\r\n\t\t\t$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);\r\n\t\t\t$startElement = $($blacklistExcluded[0]);\r\n\r\n\t\t\t// Follow an index step\r\n\t\t\t$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n\t\t\t// Return that shit!\r\n\t\t\treturn $targetNode; \r\n\t\t}\r\n\r\n\t\t// TODO: Other types of indirection\r\n\t\t// TODO: $targetNode.is(\"embed\")) : src\r\n\t\t// TODO: ($targetNode.is(\"object\")) : data\r\n\t\t// TODO: ($targetNode.is(\"image\") || $targetNode.is(\"xlink:href\")) : xlink:href\r\n\t},\r\n\r\n\t// Description: Injects an element at the specified text node\r\n\t// Arguments: a cfi text termination string, a jquery object to the current node\r\n\t// REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus\r\n\ttextTermination : function ($currNode, textOffset, elementToInject) {\r\n\r\n\t\tvar $injectedElement;\r\n\t\t// Get the first node, this should be a text node\r\n\t\tif ($currNode === undefined) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.NodeTypeError($currNode, \"expected a terminating node, or node list\");\r\n\t\t} \r\n\t\telse if ($currNode.length === 0) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"no nodes found for termination condition\");\r\n\t\t}\r\n\r\n\t\t$injectedElement = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);\r\n\t\treturn $injectedElement;\r\n\t},\r\n\r\n\t// Description: Checks that the id assertion for the node target matches that on \r\n\t//   the found node. \r\n\ttargetIdMatchesIdAssertion : function ($foundNode, idAssertion) {\r\n\r\n\t\tif ($foundNode.attr(\"id\") === idAssertion) {\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t},\r\n\r\n\t// ------------------------------------------------------------------------------------ //\r\n\t//  \"PRIVATE\" HELPERS                                                                   //\r\n\t// ------------------------------------------------------------------------------------ //\r\n\r\n\t// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer\r\n\telementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n\t\tvar $targetNode;\r\n\t\tvar $blacklistExcluded;\r\n\t\tvar numElements;\r\n\t\tvar jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;\r\n\r\n\t\t$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);\r\n\t\tnumElements = $blacklistExcluded.length;\r\n\r\n\t\tif (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {\r\n\r\n\t\t\tthrow cfiRuntimeErrors.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, \"\");\r\n\t\t}\r\n\r\n\t    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);\r\n\t\treturn $targetNode;\r\n\t},\r\n\r\n\tretrieveItemRefHref : function ($itemRefElement, $packageDocument) {\r\n\r\n\t\treturn $(\"#\" + $itemRefElement.attr(\"idref\"), $packageDocument).attr(\"href\");\r\n\t},\r\n\r\n\tindexOutOfRange : function (targetIndex, numChildElements) {\r\n\r\n\t\treturn (targetIndex > numChildElements - 1) ? true : false;\r\n\t},\r\n\r\n\t// Rationale: In order to inject an element into a specific position, access to the parent object \r\n\t//   is required. This is obtained with the jquery parent() method. An alternative would be to \r\n\t//   pass in the parent with a filtered list containing only children that are part of the target text node.\r\n    injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {\r\n        var document = $textNodeList[0].ownerDocument;\r\n\r\n        var nodeNum;\r\n        var currNodeLength;\r\n        var currTextPosition = 0;\r\n        var nodeOffset;\r\n        var originalText;\r\n        var $injectedNode;\r\n        var $newTextNode;\r\n        // The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)\r\n        for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {\r\n\r\n            if ($textNodeList[nodeNum].nodeType === Node.TEXT_NODE) {\r\n\r\n                currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length  + currTextPosition;\r\n                nodeOffset = textOffset - currTextPosition;\r\n\r\n                if (currNodeMaxIndex > textOffset) {\r\n\r\n                    // This node is going to be split and the components re-inserted\r\n                    originalText = $textNodeList[nodeNum].nodeValue;\t\r\n\r\n                    // Before part\r\n                    $textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);\r\n\r\n                    // Injected element\r\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\r\n\r\n                    // After part\r\n                    $newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));\r\n                    $($newTextNode).insertAfter($injectedNode);\r\n\r\n                    return $injectedNode;\r\n                } else if (currNodeMaxIndex == textOffset){\r\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\r\n                    return $injectedNode;\r\n                }\r\n                else {\r\n                    currTextPosition = currNodeMaxIndex;\r\n                }\r\n            } else if($textNodeList[nodeNum].nodeType === Node.COMMENT_NODE){\r\n            \tcurrNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + 7 + currTextPosition;\r\n                currTextPosition = currNodeMaxIndex;\r\n            } else if($textNodeList[nodeNum].nodeType === Node.PROCESSING_INSTRUCTION_NODE){\r\n            \tcurrNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + $textNodeList[nodeNum].target.length + 5\r\n                currTextPosition = currNodeMaxIndex;\r\n            }\r\n        }\r\n\r\n        throw cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"The offset exceeded the length of the text\");\r\n    },\r\n\r\n\t// Rationale: In order to inject an element into a specific position, access to the parent object \r\n\t//   is required. This is obtained with the jquery parent() method. An alternative would be to \r\n\t//   pass in the parent with a filtered list containing only children that are part of the target text node.\r\n\r\n\t// Description: This method finds a target text node and then injects an element into the appropriate node\r\n\t// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to \r\n\t//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that\r\n\t//   the set of nodes that compromised the original target text node are inferred and returned.\r\n\t// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, \r\n\t//   element nodes (maybe), or possibly a mix. \r\n\t// REFACTORING CANDIDATE: This method is pretty long (and confusing). Worth investigating to see if it can be refactored into something clearer.\r\n\tinferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\t\t\r\n\t\tvar $elementsWithoutMarkers;\r\n\t\tvar currLogicalTextNodeIndex;\r\n\t\tvar targetLogicalTextNodeIndex;\r\n\t\tvar nodeNum;\r\n\t\tvar $targetTextNodeList;\r\n\t\tvar prevNodeWasTextNode;\r\n\r\n\t\t// Remove any cfi marker elements from the set of elements. \r\n\t\t// Rationale: A filtering function is used, as simply using a class selector with jquery appears to \r\n\t\t//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.\r\n\t\t$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n\t\t// Convert CFIStepValue to logical index; assumes odd integer for the step value\r\n\t\ttargetLogicalTextNodeIndex = ((parseInt(CFIStepValue) + 1) / 2) - 1;\r\n\r\n\t\t// Set text node position counter\r\n\t\tcurrLogicalTextNodeIndex = 0;\r\n\t\tprevNodeWasTextNode = false;\r\n\t\t$targetTextNodeList = $elementsWithoutMarkers.filter(\r\n\t\t\tfunction () {\r\n\r\n\t\t\t\tif (currLogicalTextNodeIndex === targetLogicalTextNodeIndex) {\r\n\r\n\t\t\t\t\t// If it's a text node\r\n\t\t\t\t\tif (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n\t\t\t\t\t\tprevNodeWasTextNode = true;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Rationale: The logical text node position is only incremented once a group of text nodes (a single logical\r\n\t\t\t\t\t//   text node) has been passed by the loop. \r\n\t\t\t\t\telse if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE)) {\r\n\t\t\t\t\t\tcurrLogicalTextNodeIndex++;\r\n\t\t\t\t\t\tprevNodeWasTextNode = false;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Don't return any elements\r\n\t\t\t\telse {\r\n\r\n\t\t\t\t\tif (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n\t\t\t\t\t\tprevNodeWasTextNode = true;\r\n\t\t\t\t\t}else if (!prevNodeWasTextNode && this.nodeType === Node.ELEMENT_NODE){\r\n                        currLogicalTextNodeIndex++;\r\n\t\t\t\t\t\tprevNodeWasTextNode = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE) && (this !== $elementsWithoutMarkers.lastChild)) {\r\n\t\t\t\t\t\tcurrLogicalTextNodeIndex++;\r\n\t\t\t\t\t\tprevNodeWasTextNode = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// The filtering above should have counted the number of \"logical\" text nodes; this can be used to \r\n\t\t// detect out of range errors\r\n\t\tif ($targetTextNodeList.length === 0) {\r\n\t\t\tthrow cfiRuntimeErrors.OutOfRangeError(targetLogicalTextNodeIndex, currLogicalTextNodeIndex, \"Index out of range\");\r\n\t\t}\r\n\r\n\t\t// return the text node list\r\n\t\treturn $targetTextNodeList;\r\n\t},\r\n\r\n\tapplyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $filteredElements;\r\n\r\n        $filteredElements = $elements.filter(\r\n            function () {\r\n\r\n                var $currElement = $(this);\r\n                var includeInList = true;\r\n\r\n                if (classBlacklist) {\r\n\r\n                \t// Filter each element with the class type\r\n                \t$.each(classBlacklist, function (index, value) {\r\n\r\n\t                    if ($currElement.hasClass(value)) {\r\n\t                    \tincludeInList = false;\r\n\r\n\t                    \t// Break this loop\r\n\t                        return false;\r\n\t                    }\r\n                \t});\r\n                }\r\n\r\n                if (elementBlacklist) {\r\n                \t\r\n\t                // For each type of element\r\n\t                $.each(elementBlacklist, function (index, value) {\r\n\r\n\t                    if ($currElement.is(value)) {\r\n\t                    \tincludeInList = false;\r\n\r\n\t                    \t// Break this loop\r\n\t                        return false;\r\n\t                    }\r\n\t                });\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (idBlacklist) {\r\n                \t\r\n\t                // For each type of element\r\n\t                $.each(idBlacklist, function (index, value) {\r\n\r\n\t                    if ($currElement.attr(\"id\") === value) {\r\n\t                    \tincludeInList = false;\r\n\r\n\t                    \t// Break this loop\r\n\t                        return false;\r\n\t                    }\r\n\t                });\r\n\t\t\t\t}\r\n\r\n                return includeInList;\r\n            }\r\n        );\r\n\r\n        return $filteredElements;\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_instructions\");\r\n    \r\n    define('cfi_instructions',['jquery', './cfi_runtime_errors'],\r\n    function ($, cfiRuntimeErrors) {\r\n        return init($, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_instructions\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.CFIInstructions = \r\n    init($,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\r\n    \r\n    if (typeof cfiParser === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiParser\");\r\n    }\r\n    \r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n    \r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n    \r\nvar obj = {\r\n\r\n// Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter\r\n//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will\r\n//   represent the position or area in the EPUB referenced by a CFI.\r\n// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the\r\n//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a\r\n//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps \r\n//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references\r\n//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is \r\n//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to \r\n//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand. \r\n// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free. \r\n//   Might want to make the script die in those instances, once the grammar and interpreter are more stable. \r\n// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated. \r\n//   Whoops. There shouldn't be any interference, however, I think this should be changed. \r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    // Description: Find the content document referenced by the spine item. This should be the spine item \r\n    //   referenced by the first indirection step in the CFI.\r\n    // Rationale: This method is a part of the API so that the reading system can \"interact\" the content document \r\n    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with \r\n    //   the reading system, as it stands now. \r\n    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $packageDocument = $(packageDocument);\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n\r\n        if (!CFIAST || CFIAST.type !== \"CFIAST\") { \r\n            throw cfiRuntimeErrors.NodeTypeError(CFIAST, \"expected CFI AST root node\");\r\n        }\r\n\r\n        // Interpet the path node (the package document step)\r\n        var $packageElement = $($(\"package\", $packageDocument)[0]);\r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        foundHref = this.searchLocalPathForHref($currElement, $packageDocument, CFIAST.cfiString.localPath, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        if (foundHref) {\r\n            return foundHref;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    },\r\n\r\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\r\n    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning \r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented\r\n        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);\r\n\r\n        // Return the element that was injected into\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\r\n    injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(rangeCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        var $range1TargetElement;\r\n        var $range2TargetElement;\r\n\r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning \r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps in the first local path\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the first range local_path\r\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        $range1TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range1.termStep, $range1TargetElement, startElementToInject);\r\n\r\n        // Interpret the second range local_path\r\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        $range2TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range2.termStep, $range2TargetElement, endElementToInject);\r\n\r\n        // Return the element that was injected into\r\n        return {\r\n            startElement : $range1TargetElement[0],\r\n            endElement : $range2TargetElement[0]\r\n        };\r\n    },\r\n\r\n    // Description: This method will return the element or node (say, a text node) that is the final target of the \r\n    //   the CFI.\r\n    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(CFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        \r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning \r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        return $currElement;\r\n    },\r\n\r\n    // Description: This method will return the start and end elements (along with their char offsets) that are the final targets of the range CFI.\r\n    getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(rangeCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var indirectionStepNum;\r\n        var $currElement;\r\n        var $range1TargetElement;\r\n        var $range2TargetElement;\r\n        \r\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning \r\n        //   of the indirection step that referenced the content document.\r\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\r\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\r\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\r\n        indirectionNode.type = \"indexStep\";\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret first range local_path\r\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret second range local_path\r\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Get the start and end character offsets\r\n        var startOffset = parseInt(CFIAST.cfiString.range1.termStep.offsetValue) || undefined;\r\n        var endOffset = parseInt(CFIAST.cfiString.range2.termStep.offsetValue) || undefined;\r\n\r\n        // Return the element (and char offsets) at the end of the CFI\r\n        return {\r\n            startElement: $range1TargetElement[0],\r\n            startOffset: startOffset,\r\n            endElement: $range2TargetElement[0],\r\n            endOffset: endOffset\r\n        };\r\n    },\r\n\r\n    // Description: This method allows a \"partial\" CFI to be used to reference a target in a content document, without a \r\n    //   package document CFI component. \r\n    // Arguments: {\r\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be \r\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\r\n    //        that has no defined meaning in the spec.)\r\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. \r\n    // }\r\n    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care\r\n    getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(contentDocumentCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        \r\n        // Interpret the path node \r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        return $currElement;        \r\n    },\r\n\r\n    // Description: This method allows a \"partial\" CFI to be used, with a content document, to return the text node and offset \r\n    //    referenced by the partial CFI.\r\n    // Arguments: {\r\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be \r\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\r\n    //        that has no defined meaning in the spec.)\r\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers. \r\n    // }\r\n    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care\r\n    getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var decodedCFI = decodeURI(contentDocumentCFI);\r\n        var CFIAST = cfiParser.parse(decodedCFI);\r\n        var indirectionNode;\r\n        var textOffset;\r\n        \r\n        // Interpret the path node \r\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Interpret the rest of the steps\r\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the element at the end of the CFI\r\n        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);\r\n        return { textNode : $currElement,\r\n                 textOffset : textOffset\r\n            };\r\n    },\r\n    // Description: This function will determine if the input CFI is expressed as a range\r\n    isRangeCfi: function (cfi) {\r\n        var CFIAST = cfiParser.parse(cfi);\r\n        return CFIAST.cfiString.range1 ? true : false;\r\n    },\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PRIVATE\" HELPERS                                                                   //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    getFirstIndirectionStepNum : function (CFIAST) {\r\n\r\n        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it \r\n        //   references is already loaded and has been passed to this method\r\n        var stepNum = 0;\r\n        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {\r\n        \r\n            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];\r\n            if (nextStepNode.type === \"indirectionStep\") {\r\n                return stepNum;\r\n            }\r\n        }\r\n    },\r\n\r\n    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the \r\n    //   starting step... probably a good idea, this would make the meaning of this method clearer.\r\n    interpretLocalPath : function (localPathNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var stepNum = startStepNum;\r\n        var nextStepNode;\r\n        for (stepNum; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\r\n        \r\n            nextStepNode = localPathNode.steps[stepNum];\r\n            if (nextStepNode.type === \"indexStep\") {\r\n\r\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n            else if (nextStepNode.type === \"indirectionStep\") {\r\n\r\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n        }\r\n\r\n        return $currElement;\r\n    },\r\n\r\n    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Check node type; throw error if wrong type\r\n        if (indexStepNode === undefined || indexStepNode.type !== \"indexStep\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(indexStepNode, \"expected index step node\");\r\n        }\r\n\r\n        // Index step\r\n        var $stepTarget = cfiInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Check the id assertion, if it exists\r\n        if (indexStepNode.idAssertion) {\r\n\r\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {\r\n\r\n                throw cfiRuntimeErrors.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\r\n            }\r\n        }\r\n\r\n        return $stepTarget;\r\n    },\r\n\r\n    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Check node type; throw error if wrong type\r\n        if (indirectionStepNode === undefined || indirectionStepNode.type !== \"indirectionStep\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(indirectionStepNode, \"expected indirection step node\");\r\n        }\r\n\r\n        // Indirection step\r\n        var $stepTarget = cfiInstructions.followIndirectionStep(\r\n            indirectionStepNode.stepLength, \r\n            $currElement, \r\n            classBlacklist, \r\n            elementBlacklist);\r\n\r\n        // Check the id assertion, if it exists\r\n        if (indirectionStepNode.idAssertion) {\r\n\r\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {\r\n\r\n                throw cfiRuntimeErrors.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\r\n            }\r\n        }\r\n\r\n        return $stepTarget;\r\n    },\r\n\r\n    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus\r\n    //   to inject content into the found node. This will not always be the case, and different types of interpretation\r\n    //   are probably desired. \r\n    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {\r\n\r\n        if (terminusNode === undefined || terminusNode.type !== \"textTerminus\") {\r\n\r\n            throw cfiRuntimeErrors.NodeTypeError(terminusNode, \"expected text terminus node\");\r\n        }\r\n\r\n        var $injectedElement = cfiInstructions.textTermination(\r\n            $currElement, \r\n            terminusNode.offsetValue, \r\n            elementToInject\r\n            );\r\n\r\n        return $injectedElement;\r\n    },\r\n\r\n    searchLocalPathForHref : function ($currElement, $packageDocument, localPathNode, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Interpret the first local_path node, which is a set of steps and and a terminus condition\r\n        var stepNum = 0;\r\n        var nextStepNode;\r\n        for (stepNum = 0 ; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\r\n        \r\n            nextStepNode = localPathNode.steps[stepNum];\r\n            if (nextStepNode.type === \"indexStep\") {\r\n                \r\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n            else if (nextStepNode.type === \"indirectionStep\") {\r\n\r\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\r\n            }\r\n\r\n            // Found the content document href referenced by the spine item \r\n            if ($currElement.is(\"itemref\")) {\r\n\r\n                return cfiInstructions.retrieveItemRefHref($currElement, $packageDocument);\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_interpreter\");\r\n    \r\n    define('cfi_interpreter',['jquery', './cfi_parser', './cfi_instructions', './cfi_runtime_errors'],\r\n    function ($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\r\n        return init($, cfiParser, cfiInstructions, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_interpreter\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.Interpreter = \r\n    init($,\r\n        global.EPUBcfi.Parser,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function($, cfiInstructions, cfiRuntimeErrors) {\r\n    \r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n    \r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n    \r\nvar obj = {\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        var docRange;\r\n        var commonAncestor;\r\n        var range1OffsetStep;\r\n        var range1CFI;\r\n        var range2OffsetStep;\r\n        var range2CFI;\r\n        var commonCFIComponent;\r\n\r\n        this.validateStartTextNode(rangeStartElement);\r\n        this.validateStartTextNode(rangeEndElement);\r\n\r\n        // Parent element is the same\r\n        if ($(rangeStartElement).parent()[0] === $(rangeEndElement).parent()[0]) {\r\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);          \r\n            commonCFIComponent = this.createCFIElementSteps($(rangeStartElement).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1OffsetStep + \",\" + range2OffsetStep;\r\n        }\r\n        else {\r\n\r\n            // Create a document range to find the common ancestor\r\n            docRange = document.createRange();\r\n            docRange.setStart(rangeStartElement, startOffset);\r\n            docRange.setEnd(rangeEndElement, endOffset);\r\n            commonAncestor = docRange.commonAncestorContainer;\r\n\r\n            // Generate terminating offset and range 1\r\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;\r\n\r\n            // Generate terminating offset and range 2\r\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n            range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;\r\n\r\n            // Generate shared component\r\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n            // Return the result\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n        }\r\n    },\r\n\r\n    generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        var docRange;\r\n        var commonAncestor;\r\n        var range1CFI;\r\n        var range2CFI;\r\n        var commonCFIComponent;\r\n\r\n        this.validateStartElement(rangeStartElement);\r\n        this.validateStartElement(rangeEndElement);\r\n\r\n        if (rangeStartElement === rangeEndElement) {\r\n            throw new Error(\"Start and end element cannot be the same for a CFI range\");\r\n        }\r\n\r\n        // Create a document range to find the common ancestor\r\n        docRange = document.createRange();\r\n        docRange.setStart(rangeStartElement, 0);\r\n        docRange.setEnd(rangeEndElement, rangeEndElement.childNodes.length);\r\n        commonAncestor = docRange.commonAncestorContainer;\r\n\r\n        // Generate range 1\r\n        range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Generate range 2\r\n        range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Generate shared component\r\n        commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Return the result\r\n        return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n    },\r\n\r\n    generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n        var document = rangeStartElement.ownerDocument;\r\n\r\n        if(rangeStartElement.nodeType === Node.ELEMENT_NODE && rangeEndElement.nodeType === Node.ELEMENT_NODE){\r\n            return this.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        } else if(rangeStartElement.nodeType === Node.TEXT_NODE && rangeEndElement.nodeType === Node.TEXT_NODE){\r\n            return this.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        } else {\r\n            var docRange;\r\n            var range1CFI;\r\n            var range1OffsetStep;\r\n            var range2CFI;\r\n            var range2OffsetStep;\r\n            var commonAncestor;\r\n            var commonCFIComponent;\r\n\r\n            // Create a document range to find the common ancestor\r\n            docRange = document.createRange();\r\n            docRange.setStart(rangeStartElement, startOffset);\r\n            docRange.setEnd(rangeEndElement, endOffset);\r\n            commonAncestor = docRange.commonAncestorContainer;\r\n\r\n            if(rangeStartElement.nodeType === Node.ELEMENT_NODE){\r\n                this.validateStartElement(rangeStartElement);\r\n                range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n            } else {\r\n                this.validateStartTextNode(rangeStartElement);\r\n                // Generate terminating offset and range 1\r\n                range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n                if($(rangeStartElement).parent().is(commonAncestor)){\r\n                    range1CFI = range1OffsetStep;\r\n                } else {\r\n                    range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;    \r\n                }\r\n            }\r\n\r\n            if(rangeEndElement.nodeType === Node.ELEMENT_NODE){\r\n                this.validateStartElement(rangeEndElement);\r\n                range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\r\n            } else {\r\n                this.validateStartTextNode(rangeEndElement);\r\n                // Generate terminating offset and range 2\r\n                range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n                if($(rangeEndElement).parent().is(commonAncestor)){\r\n                    range2CFI = range2OffsetStep;\r\n                } else {\r\n                    range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;    \r\n                }                \r\n            }\r\n\r\n            // Generate shared component\r\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n            // Return the result\r\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\r\n        }\r\n    },\r\n\r\n    // Description: Generates a character offset CFI \r\n    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the \r\n    //   content document that contains the text node, the package document for this EPUB.\r\n    generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var textNodeStep;\r\n        var contentDocCFI;\r\n        var $itemRefStartNode;\r\n        var packageDocCFI;\r\n\r\n        this.validateStartTextNode(startTextNode, characterOffset);\r\n\r\n        // Create the text node step\r\n        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\r\n        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;\r\n        return contentDocCFI.substring(1, contentDocCFI.length);\r\n    },\r\n\r\n    generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var contentDocCFI;\r\n        var $itemRefStartNode;\r\n        var packageDocCFI;\r\n\r\n        this.validateStartElement(startElement);\r\n\r\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\r\n        contentDocCFI = this.createCFIElementSteps($(startElement), \"html\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Remove the ! \r\n        return contentDocCFI.substring(1, contentDocCFI.length);\r\n    },\r\n\r\n    generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        this.validateContentDocumentName(contentDocumentName);\r\n        this.validatePackageDocument(packageDocument, contentDocumentName);\r\n\r\n        // Get the start node (itemref element) that references the content document\r\n        $itemRefStartNode = $(\"itemref[idref='\" + contentDocumentName + \"']\", $(packageDocument));\r\n\r\n        // Create the steps up to the top element of the package document (the \"package\" element)\r\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\r\n        return packageDocCFIComponent + \"!\";\r\n    },\r\n\r\n    generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        // Get the start node (itemref element) that references the content document\r\n        $itemRefStartNode = $($(\"spine\", packageDocument).children()[spineIndex]);\r\n\r\n        // Create the steps up to the top element of the package document (the \"package\" element)\r\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\r\n        return packageDocCFIComponent + \"!\";\r\n    },\r\n\r\n    generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\r\n\r\n        return \"epubcfi(\" + packageDocumentCFIComponent + contentDocumentCFIComponent + \")\";  \r\n    },\r\n\r\n    // ------------------------------------------------------------------------------------ //\r\n    //  \"PRIVATE\" HELPERS                                                                   //\r\n    // ------------------------------------------------------------------------------------ //\r\n\r\n    validateStartTextNode : function (startTextNode, characterOffset) {\r\n        \r\n        // Check that the text node to start from IS a text node\r\n        if (!startTextNode) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\r\n        } else if (startTextNode.nodeType != 3) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\r\n        }\r\n\r\n        // Check that the character offset is within a valid range for the text node supplied\r\n        if (characterOffset < 0) {\r\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, 0, \"Character offset cannot be less than 0\");\r\n        }\r\n        else if (characterOffset > startTextNode.nodeValue.length) {\r\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, \"character offset cannot be greater than the length of the text node\");\r\n        }\r\n    },\r\n\r\n    validateStartElement : function (startElement) {\r\n\r\n        if (!startElement) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is undefined\");\r\n        }\r\n\r\n        if (!(startElement.nodeType && startElement.nodeType === 1)) {\r\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is not an HTML element\");\r\n        }\r\n    },\r\n\r\n    validateContentDocumentName : function (contentDocumentName) {\r\n\r\n        // Check that the idref for the content document has been provided\r\n        if (!contentDocumentName) {\r\n            throw new Error(\"The idref for the content document, as found in the spine, must be supplied\");\r\n        }\r\n    },\r\n\r\n    validatePackageDocument : function (packageDocument, contentDocumentName) {\r\n        \r\n        // Check that the package document is non-empty and contains an itemref element for the supplied idref\r\n        if (!packageDocument) {\r\n            throw new Error(\"A package document must be supplied to generate a CFI\");\r\n        }\r\n        else if ($($(\"itemref[idref='\" + contentDocumentName + \"']\", packageDocument)[0]).length === 0) {\r\n            throw new Error(\"The idref of the content document could not be found in the spine\");\r\n        }\r\n    },\r\n\r\n    // Description: Creates a CFI terminating step to a text node, with a character offset\r\n    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods\r\n    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $parentNode;\r\n        var $contentsExcludingMarkers;\r\n        var CFIIndex;\r\n        var indexOfTextNode;\r\n        var preAssertion;\r\n        var preAssertionStartIndex;\r\n        var textLength;\r\n        var postAssertion;\r\n        var postAssertionEndIndex;\r\n\r\n        // Find text node position in the set of child elements, ignoring any blacklisted elements \r\n        $parentNode = $startTextNode.parent();\r\n        $contentsExcludingMarkers = cfiInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\r\n\r\n        // Find the text node index in the parent list, inferring nodes that were originally a single text node\r\n        var prevNodeWasTextNode;\r\n        var indexOfFirstInSequence;\r\n        var textNodeOnlyIndex = 0;\r\n        var characterOffsetSinceUnsplit = 0;\r\n        var finalCharacterOffsetInSequence = 0;\r\n        $.each($contentsExcludingMarkers, \r\n            function (index) {\r\n\r\n            // If this is a text node, check if it matches and return the current index\r\n            if (this.nodeType === Node.TEXT_NODE || !prevNodeWasTextNode) {\r\n\r\n                if (this.nodeType === Node.TEXT_NODE) {\r\n                    if (this === $startTextNode[0]) {\r\n\r\n                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this \r\n                        //   node is a standard one sandwiched between two element nodes. \r\n                        if (prevNodeWasTextNode) {\r\n                            indexOfTextNode = indexOfFirstInSequence;\r\n                            finalCharacterOffsetInSequence = characterOffsetSinceUnsplit;\r\n                        } else {\r\n                            indexOfTextNode = textNodeOnlyIndex;\r\n                        }\r\n                        \r\n                        // Break out of .each loop\r\n                        return false; \r\n                    }\r\n\r\n                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length;\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                        textNodeOnlyIndex = textNodeOnlyIndex + 1;\r\n                    }\r\n                } else if (this.nodeType === Node.ELEMENT_NODE) {\r\n                    textNodeOnlyIndex = textNodeOnlyIndex + 1;\r\n                } else if (this.nodeType === Node.COMMENT_NODE) {\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // 7 is the size of the html comment tag <!--[comment]-->\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                    }\r\n                } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                    prevNodeWasTextNode = true;\r\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // 5 is the size of the instruction processing tag including the required space between the target and the data <?[target] [data]?>\r\n                    if (indexOfFirstInSequence === undefined) {\r\n                        indexOfFirstInSequence = textNodeOnlyIndex;\r\n                    }\r\n                }\r\n            }\r\n            // This node is not a text node\r\n            else if (this.nodeType === Node.ELEMENT_NODE) {\r\n                prevNodeWasTextNode = false;\r\n                indexOfFirstInSequence = undefined;\r\n                characterOffsetSinceUnsplit  = 0;\r\n            } else if (this.nodeType === Node.COMMENT_NODE) {\r\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // <!--[comment]-->\r\n            } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\r\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // <?[target] [data]?>\r\n            }\r\n        });\r\n\r\n        // Convert the text node index to a CFI odd-integer representation\r\n        CFIIndex = (indexOfTextNode * 2) + 1;\r\n\r\n        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has\r\n        //   been temporarily removed. \r\n\r\n        // Add pre- and post- text assertions\r\n        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;\r\n        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);\r\n\r\n        // textLength = $startTextNode[0].nodeValue.length;\r\n        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;\r\n        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);\r\n\r\n        // Gotta infer the correct character offset, as well\r\n\r\n        // Return the constructed CFI text node step\r\n        return \"/\" + CFIIndex + \":\" + (finalCharacterOffsetInSequence + characterOffset);\r\n         // + \"[\" + preAssertion + \",\" + postAssertion + \"]\";\r\n    },\r\n\r\n    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n\r\n        var $blacklistExcluded;\r\n        var $parentNode;\r\n        var currNodePosition;\r\n        var CFIPosition;\r\n        var idAssertion;\r\n        var elementStep; \r\n\r\n        // Find position of current node in parent list\r\n        $blacklistExcluded = cfiInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);\r\n        $.each($blacklistExcluded, \r\n            function (index, value) {\r\n\r\n                if (this === $currNode[0]) {\r\n\r\n                    currNodePosition = index;\r\n\r\n                    // Break loop\r\n                    return false;\r\n                }\r\n        });\r\n\r\n        // Convert position to the CFI even-integer representation\r\n        CFIPosition = (currNodePosition + 1) * 2;\r\n\r\n        // Create CFI step with id assertion, if the element has an id\r\n        if ($currNode.attr(\"id\")) {\r\n            elementStep = \"/\" + CFIPosition + \"[\" + $currNode.attr(\"id\") + \"]\";\r\n        }\r\n        else {\r\n            elementStep = \"/\" + CFIPosition;\r\n        }\r\n\r\n        // If a parent is an html element return the (last) step for this content document, otherwise, continue.\r\n        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the\r\n        //   top level element.\r\n        $parentNode = $currNode.parent();\r\n        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {\r\n            \r\n            // If the top level node is a type from which an indirection step, add an indirection step character (!)\r\n            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do\r\n            //   not return an indirection character. Every other type of top-level element may require an indirection\r\n            //   step to navigate to, thus requiring that ! is always prepended. \r\n            if (topLevelElement === 'html') {\r\n                return \"!\" + elementStep;\r\n            }\r\n            else {\r\n                return elementStep;\r\n            }\r\n        }\r\n        else {\r\n            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;\r\n        }\r\n    }\r\n};\r\n\r\nreturn obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_generator\");\r\n    \r\n    define('cfi_generator',['jquery', './cfi_instructions', './cfi_runtime_errors'],\r\n    function ($, cfiInstructions, cfiRuntimeErrors) {\r\n        return init($, cfiInstructions, cfiRuntimeErrors);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_generator\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    global.EPUBcfi.Generator = \r\n    init($,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        });\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\n(function(global) {\r\n\r\nvar init = function(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\r\n    \r\n    if (typeof cfiParser === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiParser\");\r\n    }\r\n    \r\n    if (typeof cfiInterpreter === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInterpreter\");\r\n    }\r\n    \r\n    if (typeof cfiInstructions === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\r\n    }\r\n    \r\n    if (typeof cfiRuntimeErrors === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\r\n    }\r\n    \r\n    if (typeof cfiGenerator === \"undefined\") {\r\n        throw new Error(\"UNDEFINED?! cfiGenerator\");\r\n    }\r\n    \r\n    var obj = {\r\n    \r\n        getContentDocHref : function (CFI, packageDocument) {\r\n            return cfiInterpreter.getContentDocHref(CFI, packageDocument);\r\n        },\r\n        injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.injectElement(CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTargetElement(CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTargetElementWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.injectRangeElements(rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getRangeTargetElements(rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        isRangeCfi : function (cfi) {\r\n          return cfiInterpreter.isRangeCfi(cfi);\r\n        },\r\n        getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiInterpreter.getTextTerminusInfoWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateCharacterOffsetCFIComponent(startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateElementCFIComponent(startElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generatePackageDocumentCFIComponent(contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\r\n            return cfiGenerator.generateCompleteCFI(packageDocumentCFIComponent, contentDocumentCFIComponent);\r\n        },\r\n        generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\r\n            return cfiGenerator.generateRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\r\n        },\r\n        injectElementAtOffset : function ($textNodeList, textOffset, elementToInject) {\r\n            return cfiInstructions.injectCFIMarkerIntoText($textNodeList, textOffset, elementToInject);\r\n        }\r\n    };\r\n    \r\n    \r\n    // TODO: remove global (should not be necessary in properly-configured RequireJS build!)\r\n    // ...but we leave it here as a \"legacy\" mechanism to access the CFI lib functionality\r\n    // -----\r\n    obj.CFIInstructions = cfiInstructions;\r\n    obj.Parser = cfiParser;\r\n    obj.Interpreter = cfiInterpreter;\r\n    obj.Generator = cfiGenerator;\r\n    \r\n    obj.NodeTypeError= cfiRuntimeErrors.NodeTypeError;\r\n    obj.OutOfRangeError = cfiRuntimeErrors.OutOfRangeError;\r\n    obj.TerminusError = cfiRuntimeErrors.TerminusError;\r\n    obj.CFIAssertionError = cfiRuntimeErrors.CFIAssertionError;\r\n    \r\n    global.EPUBcfi = obj;\r\n    // -----\r\n    \r\n    console.log(\"#######################################\");\r\n    // console.log(global.EPUBcfi);\r\n    // console.log(\"#######################################\");\r\n    \r\n    return obj;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nif (typeof define == 'function' && typeof define.amd == 'object') {\r\n    console.log(\"RequireJS ... cfi_API\");\r\n    \r\n    define('cfi_API',['./cfi_parser', './cfi_interpreter', './cfi_instructions', './cfi_runtime_errors', './cfi_generator'],\r\n    function (cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\r\n        \r\n        return init(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator);\r\n    });\r\n} else {\r\n    console.log(\"!RequireJS ... cfi_API\");\r\n    \r\n    if (!global[\"EPUBcfi\"]) {\r\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\r\n    }\r\n    \r\n    init(global.EPUBcfi.Parser,\r\n        global.EPUBcfi.Interpreter,\r\n        global.EPUBcfi.CFIInstructions,\r\n        {\r\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\r\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\r\n            TerminusError: global.EPUBcfi.TerminusError,\r\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\r\n        },\r\n        global.EPUBcfi.Generator);\r\n}\r\n\r\n})(typeof window !== \"undefined\" ? window : this);\r\n\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('readium-cfi-js',['cfi_API'], function (cfi) {\r\nreturn cfi;\r\n});\r\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//  \r\n//  Redistribution and use in source and binary forms, with or without modification, \r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this \r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice, \r\n//  this list of conditions and the following disclaimer in the documentation and/or \r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be \r\n//  used to endorse or promote products derived from this software without specific \r\n//  prior written permission.\r\n\r\ndefine('epubCfi',['readium-cfi-js'], function (cfi) {\r\nreturn cfi;\r\n});\r\n\n"
  ]
}